# Sorting
- [x] QuickSort
- [x] QuickSort: Equazioni alle ricorrenze dei 3 casi
- [x] MergeSort
- [x] CountingSort
- [x] BubbleSort
- [x] SelectionSort
- [x] InsertionSort
- [x] ShellSort

# Complessità
- [x] T(n-1)
- [x] Fibonacci
- [ ] Calcolo Combinatorio
- [ ] Altre robe strane?

# Alberi
- [x] Cos'è un BST
- [x] Altezza e profondità
- [x] Valore minimo e massimo dell'altezza
- [x] Rango e a cosa serve
- [x] Ampiezza
- [ ] Complessità

# Code a priorità
- [x] Tipi di implementazioni
- [x] Con Heap

# Heap
- [x] Tipo di implementazioni
- [x] HEAPify
- [x] HEAPBuild
- [x] HEAPSort

# Programmazione Dinamica
- [ ] Parlarne in generale
- [ ] Applicabilità
- [ ] Memoization

# Paradigma Greedy
- [x] Parlarne in generale

# Huffman
- [x] Tipi di implementazione (solo 1?)
- [x] Codici senza prefissi (prefix-free)
- [x] Perché sono di dimensioni diverse?
- [x] Cos'è la priorità di un elemento?
- [x] Cosa cambia se le stringhe sono isofrequenti?
- [x] Perché non usare direttamente gli ASCII? (la lunghezza variabile fa salvare spazio)

# Online Connectivity
- [x] Quick Find
- [x] Quick Union
- [x] Weighted Quick Union

# Hash
- [ ] Collisioni
- [ ] Clustering
- [ ] Funzioni sulle stringhe
- [ ] Open Addressing: Vantaggi e svantaggi delle varie

# Grafi
- [x] Cammino Semplice
- [x] Cammino Hamilton
- [x] DFS
- [x] DFS: Vantaggi e svantaggi tra madj e ladj
- [ ] DFS: Classificazione degli archi
- [x] BFS
- [ ] Teorema degli alberi ricoprenti minimi
- [ ] Bellman-Ford
- [x] Dijkstra
- [ ] Kosaraju
- [ ] Prim
- [ ] Kruskal
